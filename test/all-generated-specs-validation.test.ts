/**
 * üö® AUTOMATED VALIDATION OF ALL GENERATED ASYNCAPI SPECIFICATIONS
 * 
 * This test automatically discovers and validates ALL AsyncAPI specifications
 * generated by the TypeSpec emitter. It ensures ZERO TOLERANCE for invalid
 * AsyncAPI specs reaching production.
 * 
 * CRITICAL SUCCESS CRITERIA:
 * - All generated specs MUST be valid AsyncAPI 3.0.0
 * - Validation time MUST be <100ms per spec  
 * - Any invalid spec FAILS the entire build
 * - Comprehensive error reporting for failures
 */

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { AsyncAPIValidator } from "../src/validation/asyncapi-validator.js";
import { readdir, readFile, mkdir, writeFile, rm } from "node:fs/promises";
import { join, extname } from "node:path";
import {Effect} from "effect"

describe("üö® ALL GENERATED ASYNCAPI SPECS VALIDATION", () => {
  let validator: AsyncAPIValidator;
  const testOutputDir = join(process.cwd(), "test-output", "all-specs-validation");
  let discoveredSpecs: Array<{
    filePath: string;
    fileName: string;
    format: "json" | "yaml";
    size: number;
  }> = [];

  beforeAll(async () => {
    Effect.log("üîß Initializing comprehensive AsyncAPI validator...");
    
    validator = new AsyncAPIValidator({
      strict: true,
      enableCache: false, // Fresh validation for each spec
      benchmarking: true,
    });
    
    await validator.initialize();
    await mkdir(testOutputDir, { recursive: true });
    
    Effect.log("‚úÖ Validator ready for comprehensive spec validation");
  });

  afterAll(async () => {
    try {
      await rm(testOutputDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
    
    const stats = validator.getValidationStats();
    Effect.log("\nüìä FINAL VALIDATION STATISTICS:");
    Effect.log(`  üìÑ Total Validations: ${stats.totalValidations}`);
    Effect.log(`  ‚ö° Average Duration: ${stats.averageDuration.toFixed(2)}ms`);
    Effect.log(`  üìà Cache Hits: ${stats.cacheHits}`);
  });

  describe("üîç Spec Discovery and Validation Pipeline", () => {
    it("should generate sample AsyncAPI specs for validation testing", async () => {
      Effect.log("üè≠ Generating sample AsyncAPI specifications for testing...");
      
      // Generate various AsyncAPI specs to simulate real project output
      const sampleSpecs = [
        {
          name: "user-management-api",
          format: "json" as const,
          spec: {
            asyncapi: "3.0.0",
            info: {
              title: "User Management API",
              version: "1.2.0",
              description: "User lifecycle event management"
            },
            channels: {
              "user.events": {
                address: "user/events",
                description: "User lifecycle events",
                messages: {
                  userCreated: {
                    payload: {
                      type: "object",
                      properties: {
                        userId: { type: "string" },
                        name: { type: "string" },
                        email: { type: "string", format: "email" },
                        timestamp: { type: "string", format: "date-time" }
                      },
                      required: ["userId", "name", "email", "timestamp"]
                    }
                  },
                  userDeleted: {
                    payload: {
                      type: "object",
                      properties: {
                        userId: { type: "string" },
                        timestamp: { type: "string", format: "date-time" },
                        reason: { type: "string" }
                      },
                      required: ["userId", "timestamp"]
                    }
                  }
                }
              }
            },
            operations: {
              publishUserEvent: {
                action: "send",
                channel: { $ref: "#/channels/user.events" },
                description: "Publish user lifecycle events"
              },
              subscribeUserEvents: {
                action: "receive", 
                channel: { $ref: "#/channels/user.events" },
                description: "Subscribe to user events"
              }
            }
          }
        },
        {
          name: "order-processing-api",
          format: "yaml" as const,
          spec: `asyncapi: "3.0.0"
info:
  title: "Order Processing API"
  version: "2.0.0"
  description: "E-commerce order processing events"
channels:
  order.lifecycle:
    address: "orders/lifecycle"
    description: "Order lifecycle events"
    messages:
      orderCreated:
        payload:
          type: object
          properties:
            orderId:
              type: string
            customerId:
              type: string
            items:
              type: array
              items:
                type: object
                properties:
                  productId:
                    type: string
                  quantity:
                    type: integer
                  price:
                    type: number
            total:
              type: number
            timestamp:
              type: string
              format: date-time
          required:
            - orderId
            - customerId
            - items
            - total
            - timestamp
      orderFulfilled:
        payload:
          type: object
          properties:
            orderId:
              type: string
            trackingNumber:
              type: string
            timestamp:
              type: string
              format: date-time
          required:
            - orderId
            - timestamp
operations:
  publishOrderEvent:
    action: send
    channel:
      $ref: "#/channels/order.lifecycle"
    description: "Publish order lifecycle events"
  subscribeOrderEvents:
    action: receive
    channel:
      $ref: "#/channels/order.lifecycle" 
    description: "Subscribe to order events"`
        },
        {
          name: "inventory-system-api",
          format: "json" as const,
          spec: {
            asyncapi: "3.0.0",
            info: {
              title: "Inventory Management System",
              version: "1.0.0",
              description: "Real-time inventory tracking and alerts"
            },
            servers: {
              production: {
                host: "kafka.inventory.com:9092",
                protocol: "kafka",
                description: "Production Kafka cluster"
              }
            },
            channels: {
              "inventory.updates": {
                address: "inventory/updates/{productId}",
                description: "Product inventory updates",
                parameters: {
                  productId: {
                    description: "Product identifier",
                    examples: ["PROD-001", "PROD-002"]
                  }
                },
                messages: {
                  stockUpdated: {
                    payload: {
                      type: "object",
                      properties: {
                        productId: { type: "string" },
                        currentStock: { type: "integer", minimum: 0 },
                        reservedStock: { type: "integer", minimum: 0 },
                        lowStockThreshold: { type: "integer", minimum: 0 },
                        timestamp: { type: "string", format: "date-time" },
                        warehouse: { type: "string" }
                      },
                      required: ["productId", "currentStock", "timestamp"]
                    }
                  }
                }
              },
              "inventory.alerts": {
                address: "inventory/alerts",
                description: "Inventory alert notifications",
                messages: {
                  lowStockAlert: {
                    payload: {
                      type: "object",
                      properties: {
                        productId: { type: "string" },
                        currentStock: { type: "integer" },
                        threshold: { type: "integer" },
                        severity: {
                          type: "string",
                          enum: ["low", "critical", "out-of-stock"]
                        },
                        timestamp: { type: "string", format: "date-time" }
                      },
                      required: ["productId", "currentStock", "severity", "timestamp"]
                    }
                  }
                }
              }
            },
            operations: {
              publishInventoryUpdate: {
                action: "send",
                channel: { $ref: "#/channels/inventory.updates" },
                description: "Publish inventory stock updates"
              },
              subscribeInventoryUpdates: {
                action: "receive",
                channel: { $ref: "#/channels/inventory.updates" },
                description: "Subscribe to inventory updates for specific product"
              },
              subscribeInventoryAlerts: {
                action: "receive",
                channel: { $ref: "#/channels/inventory.alerts" },
                description: "Subscribe to inventory alerts"
              }
            },
            components: {
              schemas: {
                InventoryUpdate: {
                  type: "object",
                  properties: {
                    productId: { type: "string" },
                    stockLevel: { type: "integer" },
                    timestamp: { type: "string", format: "date-time" }
                  }
                },
                StockAlert: {
                  type: "object",
                  properties: {
                    productId: { type: "string" },
                    alertType: { type: "string" },
                    threshold: { type: "integer" }
                  }
                }
              }
            }
          }
        },
        {
          name: "notification-service-api", 
          format: "json" as const,
          spec: {
            asyncapi: "3.0.0",
            info: {
              title: "Notification Service API",
              version: "1.5.0",
              description: "Multi-channel notification delivery system"
            },
            channels: {
              "notifications.email": {
                address: "notifications/email",
                description: "Email notification channel",
                messages: {
                  emailNotification: {
                    payload: {
                      type: "object",
                      properties: {
                        notificationId: { type: "string" },
                        recipientEmail: { type: "string", format: "email" },
                        subject: { type: "string" },
                        body: { type: "string" },
                        priority: {
                          type: "string",
                          enum: ["low", "normal", "high", "urgent"]
                        },
                        timestamp: { type: "string", format: "date-time" }
                      },
                      required: ["notificationId", "recipientEmail", "subject", "body", "timestamp"]
                    }
                  }
                }
              },
              "notifications.push": {
                address: "notifications/push",
                description: "Push notification channel",
                messages: {
                  pushNotification: {
                    payload: {
                      type: "object",
                      properties: {
                        notificationId: { type: "string" },
                        deviceToken: { type: "string" },
                        title: { type: "string" },
                        message: { type: "string" },
                        data: { type: "object" },
                        timestamp: { type: "string", format: "date-time" }
                      },
                      required: ["notificationId", "deviceToken", "title", "message", "timestamp"]
                    }
                  }
                }
              }
            },
            operations: {
              sendEmailNotification: {
                action: "send",
                channel: { $ref: "#/channels/notifications.email" },
                description: "Send email notifications"
              },
              sendPushNotification: {
                action: "send", 
                channel: { $ref: "#/channels/notifications.push" },
                description: "Send push notifications"
              }
            }
          }
        }
      ];

      // Write all sample specs to test directory
      let generatedCount = 0;
      for (const sample of sampleSpecs) {
        const fileName = `${sample.name}.${sample.format}`;
        const filePath = join(testOutputDir, fileName);
        
        const content = sample.format === "json" 
          ? JSON.stringify(sample.spec, null, 2)
          : String(sample.spec);
        
        await writeFile(filePath, content);
        
        // Update the shared discoveredSpecs array
        const existingIndex = discoveredSpecs.findIndex(spec => spec.fileName === fileName);
        const specEntry = {
          filePath,
          fileName,
          format: sample.format,
          size: content.length
        };
        
        if (existingIndex >= 0) {
          discoveredSpecs[existingIndex] = specEntry;
        } else {
          discoveredSpecs.push(specEntry);
        }
        
        generatedCount++;
      }

      Effect.log(`‚úÖ Generated ${generatedCount} sample AsyncAPI specifications`);
      expect(generatedCount).toBe(sampleSpecs.length);
      expect(discoveredSpecs.length).toBeGreaterThan(0);
    });

    it("should discover all AsyncAPI specification files", async () => {
      Effect.log("üîç Discovering AsyncAPI specification files...");
      
      // Also scan common output directories for real generated specs
      const potentialDirs = [
        testOutputDir,
        join(process.cwd(), "dist"),
        join(process.cwd(), "build"),
        join(process.cwd(), "output"),
        join(process.cwd(), "generated")
      ];

      for (const dir of potentialDirs) {
        try {
          const files = await readdir(dir, { withFileTypes: true });
          
          for (const file of files) {
            if (file.isFile()) {
              const ext = extname(file.name).toLowerCase();
              if (ext === ".json" || ext === ".yaml" || ext === ".yml") {
                const filePath = join(dir, file.name);
                
                try {
                  // Check if it's an AsyncAPI file by looking for asyncapi field
                  const content = await readFile(filePath, "utf-8");
                  if (content.includes('"asyncapi"') || content.includes('asyncapi:')) {
                    // Avoid duplicates
                    if (!discoveredSpecs.some(spec => spec.filePath === filePath)) {
                      discoveredSpecs.push({
                        filePath,
                        fileName: file.name,
                        format: ext === ".json" ? "json" : "yaml",
                        size: content.length
                      });
                    }
                  }
                } catch (error) {
                  // Skip files that can't be read
                  Effect.log(`‚ö†Ô∏è  Skipped unreadable file: ${file.name}`);
                }
              }
            }
          }
        } catch (error) {
          // Directory doesn't exist or can't be read - skip
        }
      }

      Effect.log(`üéØ Discovered ${discoveredSpecs.length} AsyncAPI specification files`);
      Effect.log("üìã Files found:");
      discoveredSpecs.forEach(spec => {
        Effect.log(`  üìÑ ${spec.fileName} (${spec.format.toUpperCase()}, ${spec.size} bytes)`);
      });

      expect(discoveredSpecs.length).toBeGreaterThan(0);
    });

    it("should validate ALL discovered AsyncAPI specifications", async () => {
      Effect.log("\nüö® VALIDATING ALL DISCOVERED ASYNCAPI SPECIFICATIONS");
      Effect.log(`üìä Total specifications to validate: ${discoveredSpecs.length}`);
      
      if (discoveredSpecs.length === 0) {
        throw new Error("‚ùå NO ASYNCAPI SPECIFICATIONS FOUND - VALIDATION CANNOT PROCEED");
      }

      const validationResults: Array<{
        fileName: string;
        filePath: string;
        format: string;
        valid: boolean;
        duration: number;
        errors: number;
        errorDetails: string[];
        size: number;
      }> = [];

      let totalValidationTime = 0;
      const batchStartTime = performance.now();

      // Validate each discovered specification
      for (let i = 0; i < discoveredSpecs.length; i++) {
        const spec = discoveredSpecs[i];
        Effect.log(`\nüìÑ [${i + 1}/${discoveredSpecs.length}] Validating: ${spec.fileName}`);
        
        const validationStartTime = performance.now();
        const result = await validator.validateFile(spec.filePath);
        const validationDuration = performance.now() - validationStartTime;
        
        totalValidationTime += validationDuration;

        const resultSummary = {
          fileName: spec.fileName,
          filePath: spec.filePath,
          format: spec.format,
          valid: result.valid,
          duration: result.metrics.duration,
          errors: result.errors.length,
          errorDetails: result.errors.map(e => `${e.message} (${e.keyword})`),
          size: spec.size
        };

        validationResults.push(resultSummary);

        if (result.valid) {
          Effect.log(`  ‚úÖ VALID (${result.metrics.duration.toFixed(2)}ms)`);
          Effect.log(`  üìä ${result.metrics.channelCount} channels, ${result.metrics.operationCount} operations`);
          
          // Performance requirement check
          expect(result.metrics.duration).toBeLessThan(200); // <200ms requirement
        } else {
          Effect.log(`  ‚ùå INVALID (${result.errors.length} errors)`);
          Effect.log(`  üîç Errors:`);
          result.errors.forEach(error => {
            Effect.log(`    - ${error.message} (${error.keyword}) at ${error.instancePath}`);
          });
          
          // CRITICAL: Any invalid spec fails the entire build
          throw new Error(
            `üö® INVALID ASYNCAPI SPECIFICATION DETECTED: ${spec.fileName}\n` +
            `üìÅ File: ${spec.filePath}\n` +
            `‚ùå Errors (${result.errors.length}):\n` +
            result.errors.map(e => `  - ${e.message} (${e.keyword})`).join("\n") + "\n\n" +
            `üõë This specification MUST be fixed before deployment!\n` +
            `Invalid AsyncAPI specs can cause runtime failures and integration issues.`
          );
        }
      }

      const batchDuration = performance.now() - batchStartTime;

      // CRITICAL VALIDATION SUMMARY
      const validSpecs = validationResults.filter(r => r.valid).length;
      const invalidSpecs = validationResults.length - validSpecs;
      const avgValidationTime = validationResults.reduce((sum, r) => sum + r.duration, 0) / validationResults.length;
      const maxValidationTime = Math.max(...validationResults.map(r => r.duration));

      Effect.log("\n" + "=".repeat(80));
      Effect.log("üéØ FINAL VALIDATION RESULTS");
      Effect.log("=".repeat(80));
      Effect.log(`üìÑ Total Specifications Validated: ${validationResults.length}`);
      Effect.log(`‚úÖ Valid Specifications: ${validSpecs}`);
      Effect.log(`‚ùå Invalid Specifications: ${invalidSpecs}`);
      Effect.log(`üìà Success Rate: ${((validSpecs / validationResults.length) * 100).toFixed(1)}%`);
      Effect.log(`‚è±Ô∏è  Total Validation Time: ${batchDuration.toFixed(2)}ms`);
      Effect.log(`‚ö° Average Validation Time: ${avgValidationTime.toFixed(2)}ms`);
      Effect.log(`üêå Slowest Validation: ${maxValidationTime.toFixed(2)}ms`);

      Effect.log("\nüìã Individual Results:");
      validationResults.forEach(result => {
        const status = result.valid ? "‚úÖ" : "‚ùå";
        const sizeKB = (result.size / 1024).toFixed(1);
        Effect.log(`  ${status} ${result.fileName} (${result.format.toUpperCase()}, ${sizeKB}KB, ${result.duration.toFixed(2)}ms)`);
      });

      // CRITICAL SUCCESS CRITERIA
      expect(validSpecs).toBe(validationResults.length); // 100% success rate required
      expect(invalidSpecs).toBe(0); // Zero invalid specs allowed
      expect(avgValidationTime).toBeLessThan(100); // Average validation <100ms
      expect(maxValidationTime).toBeLessThan(100); // No validation >100ms
      expect(batchDuration).toBeLessThan(10000); // Total batch <10 seconds

      if (validSpecs === validationResults.length && invalidSpecs === 0) {
        Effect.log("\nüéâ ALL ASYNCAPI SPECIFICATIONS ARE VALID!");
        Effect.log("üõ°Ô∏è  No invalid specifications detected - build can proceed safely");
        Effect.log("‚ö° All performance requirements met");
        Effect.log("üöÄ Ready for production deployment");
      }
    });
  });

  describe("üîí Validation Requirements Enforcement", () => {
    it("should enforce strict AsyncAPI 3.0.0 compliance", async () => {
      Effect.log("üîí Enforcing AsyncAPI 3.0.0 compliance requirements...");
      
      // Test with a document that has wrong version
      const wrongVersionSpec = {
        filePath: join(testOutputDir, "wrong-version-test.json"),
        content: {
          asyncapi: "2.6.0", // Wrong version
          info: { title: "Wrong Version Test", version: "1.0.0" },
          channels: {}
        }
      };

      await writeFile(
        wrongVersionSpec.filePath, 
        JSON.stringify(wrongVersionSpec.content, null, 2)
      );

      const result = await validator.validateFile(wrongVersionSpec.filePath);
      
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].keyword).toMatch(/const|asyncapi|validation-error/);
      
      Effect.log("‚úÖ Version compliance check: ENFORCED");

      // Clean up test file
      await rm(wrongVersionSpec.filePath, { force: true });
    });

    it("should enforce required field validation", async () => {
      Effect.log("üîí Enforcing required field validation...");
      
      // Test with missing required fields
      const missingFieldsSpecs = [
        {
          name: "missing-asyncapi.json",
          content: {
            // Missing asyncapi field
            info: { title: "Missing AsyncAPI", version: "1.0.0" },
            channels: {}
          },
          expectedError: "required"
        },
        {
          name: "missing-info.json", 
          content: {
            asyncapi: "3.0.0",
            // Missing info field
            channels: {}
          },
          expectedError: "required"
        }
      ];

      for (const testSpec of missingFieldsSpecs) {
        const filePath = join(testOutputDir, testSpec.name);
        await writeFile(filePath, JSON.stringify(testSpec.content, null, 2));
        
        const result = await validator.validateFile(filePath);
        
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
        expect(result.errors[0].keyword).toMatch(new RegExp(`${testSpec.expectedError}|asyncapi|validation-error`));
        
        await rm(filePath, { force: true });
      }
      
      Effect.log("‚úÖ Required field validation: ENFORCED");
    });

    it("should enforce operation action validation", async () => {
      Effect.log("üîí Enforcing operation action validation...");
      
      const invalidActionSpec = {
        asyncapi: "3.0.0",
        info: { title: "Invalid Action Test", version: "1.0.0" },
        channels: {
          "test-channel": { address: "test" }
        },
        operations: {
          invalidOp: {
            action: "invalid-action", // Should be "send" or "receive"
            channel: { $ref: "#/channels/test-channel" }
          }
        }
      };

      const filePath = join(testOutputDir, "invalid-action-test.json");
      await writeFile(filePath, JSON.stringify(invalidActionSpec, null, 2));
      
      const result = await validator.validateFile(filePath);
      
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].keyword).toMatch(/enum|asyncapi|validation-error/);
      
      Effect.log("‚úÖ Operation action validation: ENFORCED");
      
      await rm(filePath, { force: true });
    });
  });
});